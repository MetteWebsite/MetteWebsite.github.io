{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nvar SourceNode = require(\"source-map\").SourceNode;\n\nvar SourceMapConsumer = require(\"source-map\").SourceMapConsumer;\n\nvar applySourceMap = function (sourceNode, sourceMapConsumer, sourceFile, removeGeneratedCodeForSourceFile) {\n  // The following notations are used to name stuff:\n  // Left <------------> Middle <-------------------> Right\n  // Input arguments:\n  //        sourceNode                                       - Code mapping from Left to Middle\n  //                   sourceFile                            - Name of a Middle file\n  //                              sourceMapConsumer          - Code mapping from Middle to Right\n  // Variables:\n  //           l2m                      m2r\n  // Left <-----------------------------------------> Right\n  // Variables:\n  //                       l2r\n  var l2rResult = new SourceNode();\n  var l2rOutput = [];\n  var middleSourceContents = {};\n  var m2rMappingsByLine = {};\n  var rightSourceContentsSet = {};\n  var rightSourceContentsLines = {}; // Store all mappings by generated line\n\n  sourceMapConsumer.eachMapping(function (mapping) {\n    (m2rMappingsByLine[mapping.generatedLine] = m2rMappingsByLine[mapping.generatedLine] || []).push(mapping);\n  }, null, SourceMapConsumer.GENERATED_ORDER); // Store all source contents\n\n  sourceNode.walkSourceContents(function (source, content) {\n    middleSourceContents[\"$\" + source] = content;\n  });\n  var middleSource = middleSourceContents[\"$\" + sourceFile];\n  var middleSourceLines = middleSource ? middleSource.split(\"\\n\") : undefined; // Walk all left to middle mappings\n\n  sourceNode.walk(function (chunk, middleMapping) {\n    var source; // Find a mapping from middle to right\n\n    if (middleMapping.source === sourceFile && middleMapping.line && m2rMappingsByLine[middleMapping.line]) {\n      var m2rBestFit;\n      var m2rMappings = m2rMappingsByLine[middleMapping.line]; // Note: if this becomes a performance problem, use binary search\n\n      for (var i = 0; i < m2rMappings.length; i++) {\n        if (m2rMappings[i].generatedColumn <= middleMapping.column) {\n          m2rBestFit = m2rMappings[i];\n        }\n      }\n\n      if (m2rBestFit) {\n        var allowMiddleName = false;\n        var middleLine;\n        var rightSourceContent;\n        var rightSourceContentLines;\n        var rightSource = m2rBestFit.source; // Check if we have middle and right source for this mapping\n        // Then we could have an \"identify\" mapping\n\n        if (middleSourceLines && rightSource && (middleLine = middleSourceLines[m2rBestFit.generatedLine - 1]) && ((rightSourceContentLines = rightSourceContentsLines[rightSource]) || (rightSourceContent = sourceMapConsumer.sourceContentFor(rightSource, true)))) {\n          if (!rightSourceContentLines) {\n            rightSourceContentLines = rightSourceContentsLines[rightSource] = rightSourceContent.split(\"\\n\");\n          }\n\n          var rightLine = rightSourceContentLines[m2rBestFit.originalLine - 1];\n\n          if (rightLine) {\n            var offset = middleMapping.column - m2rBestFit.generatedColumn;\n\n            if (offset > 0) {\n              var middlePart = middleLine.slice(m2rBestFit.generatedColumn, middleMapping.column);\n              var rightPart = rightLine.slice(m2rBestFit.originalColumn, m2rBestFit.originalColumn + offset);\n\n              if (middlePart === rightPart) {\n                // When original and generated code is equal we assume we have an \"identity\" mapping\n                // In this case we can offset the original position\n                m2rBestFit = Object.assign({}, m2rBestFit, {\n                  originalColumn: m2rBestFit.originalColumn + offset,\n                  generatedColumn: middleMapping.column\n                });\n              }\n            }\n\n            if (!m2rBestFit.name && middleMapping.name) {\n              allowMiddleName = rightLine.slice(m2rBestFit.originalColumn, m2rBestFit.originalColumn + middleMapping.name.length) === middleMapping.name;\n            }\n          }\n        } // Construct a left to right node from the found middle to right mapping\n\n\n        source = m2rBestFit.source;\n        l2rOutput.push(new SourceNode(m2rBestFit.originalLine, m2rBestFit.originalColumn, source, chunk, allowMiddleName ? middleMapping.name : m2rBestFit.name)); // Set the source contents once\n\n        if (!(\"$\" + source in rightSourceContentsSet)) {\n          rightSourceContentsSet[\"$\" + source] = true;\n          var sourceContent = sourceMapConsumer.sourceContentFor(source, true);\n\n          if (sourceContent) {\n            l2rResult.setSourceContent(source, sourceContent);\n          }\n        }\n\n        return;\n      }\n    }\n\n    if (removeGeneratedCodeForSourceFile && middleMapping.source === sourceFile || !middleMapping.source) {\n      // Construct a left to middle node with only generated code\n      // Because user do not want mappings to middle sources\n      // Or this chunk has no mapping\n      l2rOutput.push(chunk);\n      return;\n    } // Construct a left to middle node\n\n\n    source = middleMapping.source;\n    l2rOutput.push(new SourceNode(middleMapping.line, middleMapping.column, source, chunk, middleMapping.name));\n\n    if (\"$\" + source in middleSourceContents) {\n      if (!(\"$\" + source in rightSourceContentsSet)) {\n        l2rResult.setSourceContent(source, middleSourceContents[\"$\" + source]);\n        delete middleSourceContents[\"$\" + source];\n      }\n    }\n  }); // Put output into the resulting SourceNode\n\n  l2rResult.add(l2rOutput);\n  return l2rResult;\n};\n\nmodule.exports = applySourceMap;","map":{"version":3,"sources":["C:/Users/emmab/Documents/GitHub/MetteWebsite.github.io/node_modules/webpack-sources/lib/applySourceMap.js"],"names":["SourceNode","require","SourceMapConsumer","applySourceMap","sourceNode","sourceMapConsumer","sourceFile","removeGeneratedCodeForSourceFile","l2rResult","l2rOutput","middleSourceContents","m2rMappingsByLine","rightSourceContentsSet","rightSourceContentsLines","eachMapping","mapping","generatedLine","push","GENERATED_ORDER","walkSourceContents","source","content","middleSource","middleSourceLines","split","undefined","walk","chunk","middleMapping","line","m2rBestFit","m2rMappings","i","length","generatedColumn","column","allowMiddleName","middleLine","rightSourceContent","rightSourceContentLines","rightSource","sourceContentFor","rightLine","originalLine","offset","middlePart","slice","rightPart","originalColumn","Object","assign","name","sourceContent","setSourceContent","add","module","exports"],"mappings":"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","sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar SourceNode = require(\"source-map\").SourceNode;\r\nvar SourceMapConsumer = require(\"source-map\").SourceMapConsumer;\r\n\r\nvar applySourceMap = function(\r\n\tsourceNode,\r\n\tsourceMapConsumer,\r\n\tsourceFile,\r\n\tremoveGeneratedCodeForSourceFile\r\n) {\r\n\t// The following notations are used to name stuff:\r\n\t// Left <------------> Middle <-------------------> Right\r\n\t// Input arguments:\r\n\t//        sourceNode                                       - Code mapping from Left to Middle\r\n\t//                   sourceFile                            - Name of a Middle file\r\n\t//                              sourceMapConsumer          - Code mapping from Middle to Right\r\n\t// Variables:\r\n\t//           l2m                      m2r\r\n\t// Left <-----------------------------------------> Right\r\n\t// Variables:\r\n\t//                       l2r\r\n\r\n\tvar l2rResult = new SourceNode();\r\n\tvar l2rOutput = [];\r\n\r\n\tvar middleSourceContents = {};\r\n\r\n\tvar m2rMappingsByLine = {};\r\n\r\n\tvar rightSourceContentsSet = {};\r\n\tvar rightSourceContentsLines = {};\r\n\r\n\t// Store all mappings by generated line\r\n\tsourceMapConsumer.eachMapping(\r\n\t\tfunction(mapping) {\r\n\t\t\t(m2rMappingsByLine[mapping.generatedLine] =\r\n\t\t\t\tm2rMappingsByLine[mapping.generatedLine] || []).push(mapping);\r\n\t\t},\r\n\t\tnull,\r\n\t\tSourceMapConsumer.GENERATED_ORDER\r\n\t);\r\n\r\n\t// Store all source contents\r\n\tsourceNode.walkSourceContents(function(source, content) {\r\n\t\tmiddleSourceContents[\"$\" + source] = content;\r\n\t});\r\n\r\n\tvar middleSource = middleSourceContents[\"$\" + sourceFile];\r\n\tvar middleSourceLines = middleSource ? middleSource.split(\"\\n\") : undefined;\r\n\r\n\t// Walk all left to middle mappings\r\n\tsourceNode.walk(function(chunk, middleMapping) {\r\n\t\tvar source;\r\n\r\n\t\t// Find a mapping from middle to right\r\n\t\tif(\r\n\t\t\tmiddleMapping.source === sourceFile &&\r\n\t\t\tmiddleMapping.line &&\r\n\t\t\tm2rMappingsByLine[middleMapping.line]\r\n\t\t) {\r\n\t\t\tvar m2rBestFit;\r\n\t\t\tvar m2rMappings = m2rMappingsByLine[middleMapping.line];\r\n\t\t\t// Note: if this becomes a performance problem, use binary search\r\n\t\t\tfor(var i = 0; i < m2rMappings.length; i++) {\r\n\t\t\t\tif(m2rMappings[i].generatedColumn <= middleMapping.column) {\r\n\t\t\t\t\tm2rBestFit = m2rMappings[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(m2rBestFit) {\r\n\t\t\t\tvar allowMiddleName = false;\r\n\t\t\t\tvar middleLine;\r\n\t\t\t\tvar rightSourceContent;\r\n\t\t\t\tvar rightSourceContentLines;\r\n\t\t\t\tvar rightSource = m2rBestFit.source;\r\n\t\t\t\t// Check if we have middle and right source for this mapping\r\n\t\t\t\t// Then we could have an \"identify\" mapping\r\n\t\t\t\tif(\r\n\t\t\t\t\tmiddleSourceLines &&\r\n\t\t\t\t\trightSource &&\r\n\t\t\t\t\t(middleLine = middleSourceLines[m2rBestFit.generatedLine - 1]) &&\r\n\t\t\t\t\t((rightSourceContentLines = rightSourceContentsLines[rightSource]) ||\r\n\t\t\t\t\t\t(rightSourceContent = sourceMapConsumer.sourceContentFor(\r\n\t\t\t\t\t\t\trightSource,\r\n\t\t\t\t\t\t\ttrue\r\n\t\t\t\t\t\t)))\r\n\t\t\t\t) {\r\n\t\t\t\t\tif(!rightSourceContentLines) {\r\n\t\t\t\t\t\trightSourceContentLines = rightSourceContentsLines[\r\n\t\t\t\t\t\t\trightSource\r\n\t\t\t\t\t\t] = rightSourceContent.split(\"\\n\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar rightLine = rightSourceContentLines[m2rBestFit.originalLine - 1];\r\n\t\t\t\t\tif(rightLine) {\r\n\t\t\t\t\t\tvar offset = middleMapping.column - m2rBestFit.generatedColumn;\r\n\t\t\t\t\t\tif(offset > 0) {\r\n\t\t\t\t\t\t\tvar middlePart = middleLine.slice(\r\n\t\t\t\t\t\t\t\tm2rBestFit.generatedColumn,\r\n\t\t\t\t\t\t\t\tmiddleMapping.column\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tvar rightPart = rightLine.slice(\r\n\t\t\t\t\t\t\t\tm2rBestFit.originalColumn,\r\n\t\t\t\t\t\t\t\tm2rBestFit.originalColumn + offset\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tif(middlePart === rightPart) {\r\n\t\t\t\t\t\t\t\t// When original and generated code is equal we assume we have an \"identity\" mapping\r\n\t\t\t\t\t\t\t\t// In this case we can offset the original position\r\n\t\t\t\t\t\t\t\tm2rBestFit = Object.assign({}, m2rBestFit, {\r\n\t\t\t\t\t\t\t\t\toriginalColumn: m2rBestFit.originalColumn + offset,\r\n\t\t\t\t\t\t\t\t\tgeneratedColumn: middleMapping.column\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(!m2rBestFit.name && middleMapping.name) {\r\n\t\t\t\t\t\t\tallowMiddleName =\r\n\t\t\t\t\t\t\t\trightLine.slice(\r\n\t\t\t\t\t\t\t\t\tm2rBestFit.originalColumn,\r\n\t\t\t\t\t\t\t\t\tm2rBestFit.originalColumn + middleMapping.name.length\r\n\t\t\t\t\t\t\t\t) === middleMapping.name;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Construct a left to right node from the found middle to right mapping\r\n\t\t\t\tsource = m2rBestFit.source;\r\n\t\t\t\tl2rOutput.push(\r\n\t\t\t\t\tnew SourceNode(\r\n\t\t\t\t\t\tm2rBestFit.originalLine,\r\n\t\t\t\t\t\tm2rBestFit.originalColumn,\r\n\t\t\t\t\t\tsource,\r\n\t\t\t\t\t\tchunk,\r\n\t\t\t\t\t\tallowMiddleName ? middleMapping.name : m2rBestFit.name\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// Set the source contents once\r\n\t\t\t\tif(!(\"$\" + source in rightSourceContentsSet)) {\r\n\t\t\t\t\trightSourceContentsSet[\"$\" + source] = true;\r\n\t\t\t\t\tvar sourceContent = sourceMapConsumer.sourceContentFor(source, true);\r\n\t\t\t\t\tif(sourceContent) {\r\n\t\t\t\t\t\tl2rResult.setSourceContent(source, sourceContent);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif((removeGeneratedCodeForSourceFile && middleMapping.source === sourceFile) || !middleMapping.source) {\r\n\t\t\t// Construct a left to middle node with only generated code\r\n\t\t\t// Because user do not want mappings to middle sources\r\n\t\t\t// Or this chunk has no mapping\r\n\t\t\tl2rOutput.push(chunk);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Construct a left to middle node\r\n\t\tsource = middleMapping.source;\r\n\t\tl2rOutput.push(\r\n\t\t\tnew SourceNode(\r\n\t\t\t\tmiddleMapping.line,\r\n\t\t\t\tmiddleMapping.column,\r\n\t\t\t\tsource,\r\n\t\t\t\tchunk,\r\n\t\t\t\tmiddleMapping.name\r\n\t\t\t)\r\n\t\t);\r\n\t\tif(\"$\" + source in middleSourceContents) {\r\n\t\t\tif(!(\"$\" + source in rightSourceContentsSet)) {\r\n\t\t\t\tl2rResult.setSourceContent(source, middleSourceContents[\"$\" + source]);\r\n\t\t\t\tdelete middleSourceContents[\"$\" + source];\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\t// Put output into the resulting SourceNode\r\n\tl2rResult.add(l2rOutput);\r\n\treturn l2rResult;\r\n};\r\n\r\nmodule.exports = applySourceMap;\r\n"]},"metadata":{},"sourceType":"script"}